#ifndef _ARGON2_
#define _ARGON2_

const uint8_t MIN_LANES = 1; //Minimum number of lanes (degree of parallelism)
const uint8_t MAX_LANES = 255; //Maximum number of lanes (degree of parallelism)
const uint32_t SYNC_POINTS = 4; //Number of synchronization points between lanes per pass
const uint32_t MAX_OUTLEN = 0xFFFFFFFF; //Maximum digest length in bytes
const uint32_t MIN_OUTLEN = 4; //Minimum digest size
const uint32_t MIN_MEMORY = 2 * SYNC_POINTS; //Minimum number of memory blocks: 2 per slice
const uint32_t MAX_MEMORY = 0xFFFFFFFF;//Maximum number of memory blocks: 2^32-1 KB-blocks
const uint32_t MIN_TIME = 1; //Minimum number of passes
const uint32_t MIN_PWD_LENGTH = 0;// Minimum password length in bytes
const uint32_t MAX_PWD_LENGTH = 0xFFFFFFFF; //Maximum password length in bytes
const uint32_t MIN_AD_LENGTH = 0; //Minimum associated data length in bytes
const uint32_t MAX_AD_LENGTH = 0xFFFFFFFF; //Maximum associated data length in bytes
const uint32_t MAX_SALT_LENGTH = 0xFFFFFFFF;//Maximum salt length in bytes
const uint32_t MIN_SALT_LENGTH = 8; //Minimum salt length in bytes
const uint32_t MIN_SECRET = 0; //Minimum key length in bytes
const uint32_t MAX_SECRET = 0xFFFFFFFF; //Maximum key length in bytes
const size_t BLOCK_SIZE_KILOBYTE = 1;//Memory block size
const size_t  BYTES_IN_BLOCK = (1024 * BLOCK_SIZE_KILOBYTE); //The same as above
const size_t   BLOCK_SIZE = BYTES_IN_BLOCK;
const uint8_t VERSION_NUMBER = 0x10;//Version number
const uint32_t  ADDRESSES_IN_BLOCK = (BYTES_IN_BLOCK / 4); // Number of memory addresses generated by one call to Blake in Argon2i

const uint32_t ALIGN_ARGON = 16;//Alignment parameter

const uint32_t INPUT_INITIAL_HASH_LENGTH = 64; //The inputs are first hashed with full Blake and put into the first memory blocks -- the length of this digest.

/*****************ERROR CODES*********/

const int NULL_OUTPUT_PTR = -1;
const int TOO_SHORT_OUTPUT = -2;
const int TOO_LONG_OUTPUT = -3;
const int TOO_SHORT_PWD = -4;
const int TOO_LONG_PWD = -5;
const int TOO_SHORT_SALT = -6;
const int TOO_LONG_SALT = -7;
const int TOO_SHORT_AD = -8;
const int TOO_LONG_AD = -9;
const int TOO_SHORT_SECRET = -10;
const int TOO_LONG_SECRET = -11;
const int TOO_SMALL_TIME = -12;
const int TOO_LARGE_TIME = -13;
const int TOO_LITTLE_MEMORY = -14;
const int TOO_MUCH_MEMORY = -15;
const int TOO_FEW_LANES = -16;
const int TOO_MANY_LANES = -17;


#define USEC_TO_SEC 			(1000 * 1000 * 1.0)
#define BYTES_TO_GIGABYTES 		(1024 * 1024 * 1024 * 1.0)


struct scheme_info_t
{
	uint8_t *state;
	uint32_t mem_size;
	uint32_t passes;
	uint8_t lanes;
	scheme_info_t(uint8_t* s, uint32_t m, uint32_t p, uint8_t l){ state = s; mem_size = m; passes = p; lanes = l; }
};

struct position_info_t {

	uint32_t pass;
	uint8_t slice;
	uint8_t lane;
	uint32_t index;
	position_info_t(uint32_t p = 0, uint8_t s = 0, uint8_t l = 0, uint32_t i = 0){ pass = p; slice = s; lane = l; index = i; }
};


#define KAT_FILENAME "kat-argon2d-opt.log"


extern "C" int PHS(void *out, size_t outlen, const void *in, size_t inlen, const void *salt, size_t saltlen,
	unsigned int t_cost, unsigned int m_cost);

extern int Argon2d(uint8_t *out, uint32_t outlen, const uint8_t *msg, uint32_t msglen, const uint8_t *nonce, uint32_t noncelen, const uint8_t *secret,
	uint8_t secretlen, const uint8_t *ad, uint32_t adlen, uint32_t t_cost, uint32_t m_cost, uint8_t lanes);
extern int ValidateInputs(uint8_t *out, uint32_t outlen, const uint8_t *msg, uint32_t msglen, const uint8_t *nonce, uint32_t noncelen, const uint8_t *secret,
	uint32_t secretlen, const uint8_t *ad, uint32_t adlen, uint32_t t_cost, uint32_t m_cost, uint8_t lanes);
extern void InitialHash(uint8_t* blockhash, uint32_t outlen, const uint8_t *msg, uint32_t msglen, const uint8_t *nonce, uint32_t noncelen, const uint8_t *secret,
	uint32_t secretlen, const uint8_t *ad, uint32_t adlen, uint32_t t_cost, uint32_t m_cost, uint8_t lanes);
#endif