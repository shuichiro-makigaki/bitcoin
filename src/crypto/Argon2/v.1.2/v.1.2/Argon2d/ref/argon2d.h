#ifndef _ARGON2_
#define _ARGON2_

const uint8_t MIN_LANES = 1; //Minimum number of lanes (degree of parallelism)
const uint8_t MAX_LANES = 255; //Maximum number of lanes (degree of parallelism)
const uint32_t SYNC_POINTS = 4; //Number of synchronization points between lanes per pass
const uint32_t MAX_OUTLEN = 0xFFFFFFFF; //Maximum digest length in bytes
const uint32_t MIN_OUTLEN = 4; //Minimum digest size
const uint32_t MIN_MEMORY = 2*SYNC_POINTS; //Minimum number of memory blocks: 2 per slice
const uint32_t MAX_MEMORY = 0xFFFFFFFF;//Maximum number of memory blocks: 2^32-1 KB-blocks
const uint32_t MIN_TIME = 1; //Minimum number of passes
const uint32_t MIN_PWD_LENGTH = 0;// Minimum password length in bytes
const uint32_t MAX_PWD_LENGTH = 0xFFFFFFFF; //Maximum password length in bytes
const uint32_t MIN_AD_LENGTH = 0; //Minimum associated data length in bytes
const uint32_t MAX_AD_LENGTH = 0xFFFFFFFF; //Maximum associated data length in bytes
const uint32_t MAX_SALT_LENGTH =0xFFFFFFFF;//Maximum salt length in bytes
const uint32_t MIN_SALT_LENGTH = 8; //Minimum salt length in bytes
const uint32_t MIN_SECRET = 0; //Minimum key length in bytes
const uint32_t MAX_SECRET = 0xFFFFFFFF; //Maximum key length in bytes
const size_t BLOCK_SIZE_KILOBYTE = 1;//Memory block size
const size_t  BYTES_IN_BLOCK = (1024 * BLOCK_SIZE_KILOBYTE); //The same as above
const size_t   BLOCK_SIZE = BYTES_IN_BLOCK;
const uint8_t VERSION_NUMBER = 0x10;//Version number
const uint32_t  ADDRESSES_IN_BLOCK = (BYTES_IN_BLOCK / 4); // Number of memory addresses generated by one call to Blake in Argon2i

const uint32_t ALIGN_ARGON = 16;//Alignment parameter

const uint32_t INPUT_INITIAL_HASH_LENGTH = 64; //The inputs are first hashed with full Blake and put into the first memory blocks -- the length of this digest.

/*****************ERROR CODES*********/

const int NULL_OUTPUT_PTR = -1;
const int TOO_SHORT_OUTPUT = -2;
const int TOO_LONG_OUTPUT = -3;
const int TOO_SHORT_PWD = -4;
const int TOO_LONG_PWD = -5;
const int TOO_SHORT_SALT = -6;
const int TOO_LONG_SALT = -7;
const int TOO_SHORT_AD = -8;
const int TOO_LONG_AD = -9;
const int TOO_SHORT_SECRET = -10;
const int TOO_LONG_SECRET = -11;
const int TOO_SMALL_TIME = -12;
const int TOO_LARGE_TIME = -13;
const int TOO_LITTLE_MEMORY = -14;
const int TOO_MUCH_MEMORY = -15;
const int TOO_FEW_LANES = -16;
const int TOO_MANY_LANES = -17;


//#define KAT
//#define KAT_INTERNAL
const char* KAT_FILENAME = "kat-argon2d.log";


#define _MEASURE    //Whether we measure timings

/*
Structure for the (1KB) memory block.
 Memory blocks can be copied, XORed
*/
struct block{   
	uint8_t v[BYTES_IN_BLOCK];

	block(){ memset(v, 0, BYTES_IN_BLOCK); }
	uint64_t& operator[](uint8_t i){ return *(uint64_t*)(v + 8 * i); }
	block& operator=(const block& r){ memcpy(v, r.v, BYTES_IN_BLOCK); return *this; }
	block operator^(const block& r){static block a; for (unsigned j = 0; j < BYTES_IN_BLOCK; ++j) a.v[j] = v[j] ^ r.v[j]; return a; }
};

/**
* Function to hash the inputs in the memory-hard fashion
* @param  out  Pointer to the memory where the hash digest will be written
* @param  outlen Digest length in bytes
* @param  in Pointer to the input (password)
* @param  inlen Input length in bytes
* @param  salt Pointer to the salt
* @param  saltlen Salt length in bytes
* @pre    @a out must have at least @a outlen bytes allocated
* @pre    @a in must be at least @inlen bytes long
* @pre    @a saltlen must be at least @saltlen bytes long
* @return Zero if successful, 1 otherwise.
*/

extern "C" int PHS(void *out, size_t outlen, const void *in, size_t inlen, const void *salt, size_t saltlen,
	unsigned int t_cost, unsigned int m_cost);

extern int Argon2d(uint8_t *out, uint32_t outlen, const uint8_t *msg, uint32_t msglen, const uint8_t *nonce, uint32_t noncelen, const uint8_t *secret,
	uint32_t secretlen, const uint8_t *ad, uint32_t adlen, uint32_t t_cost, uint32_t m_cost, uint8_t lanes);

#endif